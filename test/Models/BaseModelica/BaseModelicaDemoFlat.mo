function BaseModelicaDemo.SpringData "Automatically generated record constructor for BaseModelicaDemo.SpringData"
  input Real c1;
  input Real c2;
  output SpringData res;
end BaseModelicaDemo.SpringData;

function BaseModelicaDemo.springCurve
  input Real phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg");
  input BaseModelicaDemo.SpringData data;
  output Real f(quantity = "Force", unit = "N");
  protected Real aux;
algorithm
  f := phi_rel * data.c1 + phi_rel ^ 2.0 * data.c2;
  aux := 1.3;
  f := f * aux;
  f := max(f, 10.0);
  f := min(f, -10.0);
end BaseModelicaDemo.springCurve;

class BaseModelicaDemo.ExampleScalar "Example to show scalar Base Modelica Output from OpenModelica"
  Real shaft.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real shaft.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real shaft.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real shaft.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real shaft.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = 1.0 "Moment of inertia";
  final parameter enumeration(never, avoid, default, prefer, always) shaft.stateSelect = StateSelect.default "Priority to use phi and w as states";
  Real shaft.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true, stateSelect = StateSelect.default) "Absolute rotation angle of component";
  Real shaft.w(quantity = "AngularVelocity", unit = "rad/s", start = 0.0, fixed = true, stateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
  Real shaft.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
  Real load.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real load.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real load.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real load.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real load.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = 50.0 "Moment of inertia";
  final parameter enumeration(never, avoid, default, prefer, always) load.stateSelect = StateSelect.default "Priority to use phi and w as states";
  Real load.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", stateSelect = StateSelect.default) "Absolute rotation angle of component";
  Real load.w(quantity = "AngularVelocity", unit = "rad/s", start = 0.0, fixed = true, stateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
  Real load.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
  Real spring.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
  Real spring.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
  Real spring.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real spring.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real spring.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real spring.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real spring.c(quantity = "RotationalSpringConstant", unit = "N.m/rad", min = 0.0, start = 100000.0) = 1000.0 "Spring constant";
  parameter Real spring.phi_rel0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Unstretched spring angle";
  parameter Real fixed.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
  Real fixed.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real fixed.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real springDamper.c(quantity = "RotationalSpringConstant", unit = "N.m/rad", min = 0.0, start = 100000.0) = 100000.0 "Spring constant";
  parameter Real springDamper.d(quantity = "RotationalDampingConstant", unit = "N.m.s/rad", min = 0.0, start = 0.0) = 5.0 "Damping constant";
  parameter Real springDamper.phi_rel0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Unstretched spring angle";
  Real springDamper.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0, fixed = true, nominal = if springDamper.phi_nominal >= 1e-15 then springDamper.phi_nominal else 1.0, stateSelect = StateSelect.prefer) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
  Real springDamper.w_rel(quantity = "AngularVelocity", unit = "rad/s", start = 0.0, fixed = true, nominal = 0.0001, stateSelect = StateSelect.prefer) "Relative angular velocity (= der(phi_rel))";
  Real springDamper.a_rel(quantity = "AngularAcceleration", unit = "rad/s2", start = 0.0) "Relative angular acceleration (= der(w_rel))";
  Real springDamper.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
  Real springDamper.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real springDamper.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real springDamper.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real springDamper.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real springDamper.phi_nominal(quantity = "Angle", unit = "rad", displayUnit = "rad", min = 0.0) = 0.0001 "Nominal value of phi_rel (used for scaling)";
  final parameter enumeration(never, avoid, default, prefer, always) springDamper.stateSelect = StateSelect.prefer "Priority to use phi_rel and w_rel as states";
  final parameter Boolean springDamper.useHeatPort = false "= true, if heatPort is enabled";
  Real springDamper.lossPower(quantity = "Power", unit = "W") "Loss power leaving component via heatPort (> 0, if heat is flowing out of component)";
  protected Real springDamper.tau_c(quantity = "Torque", unit = "N.m") "Spring torque";
  protected Real springDamper.tau_d(quantity = "Torque", unit = "N.m") "Damping torque";
  final parameter Boolean torque.useSupport = true "= true, if support flange enabled, otherwise implicitly grounded";
  Real torque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real torque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real torque.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") = torque.phi_support "Absolute rotation angle of flange";
  Real torque.support.tau(quantity = "Torque", unit = "N.m") = -torque.flange.tau "Cut torque in the flange";
  protected Real torque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
  Real torque.tau(unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
  parameter Real ramp.height = 100.0 "Height of ramps";
  parameter Real ramp.duration(quantity = "Time", unit = "s", min = 0.0, start = 2.0) = 5.0 "Duration of ramp (= 0.0 gives a Step)";
  Real ramp.y "Connector of Real output signal";
  parameter Real ramp.offset = 0.0 "Offset of output signal y";
  parameter Real ramp.startTime(quantity = "Time", unit = "s") = 0.0 "Output y = offset for time < startTime";
  final parameter Boolean idealGear.useSupport = true "= true, if support flange enabled, otherwise implicitly grounded";
  Real idealGear.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real idealGear.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real idealGear.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real idealGear.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real idealGear.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") = idealGear.phi_support "Absolute rotation angle of flange";
  Real idealGear.support.tau(quantity = "Torque", unit = "N.m") = (-idealGear.flange_a.tau) - idealGear.flange_b.tau "Cut torque in the flange";
  protected Real idealGear.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
  parameter Real idealGear.ratio(start = 1.0) = 3.0 "Transmission ratio (flange_a.phi/flange_b.phi)";
  Real idealGear.phi_a(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle between left shaft flange and support";
  Real idealGear.phi_b(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle between right shaft flange and support";
  Real housing.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real housing.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real housing.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real housing.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real housing.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = 5.0 "Moment of inertia";
  final parameter enumeration(never, avoid, default, prefer, always) housing.stateSelect = StateSelect.default "Priority to use phi and w as states";
  Real housing.phi(quantity = "Angle", unit = "rad", displayUnit = "deg", stateSelect = StateSelect.default) "Absolute rotation angle of component";
  Real housing.w(quantity = "AngularVelocity", unit = "rad/s", stateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
  Real housing.a(quantity = "AngularAcceleration", unit = "rad/s2") "Absolute angular acceleration of component (= der(w))";
  Real multiSensor.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real multiSensor.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real multiSensor.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real multiSensor.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real multiSensor.power(unit = "W") "Power in flange flange_a as output signal";
  Real multiSensor.w(unit = "rad/s") "Absolute angular velocity of flange_a as output signal";
  Real multiSensor.tau(unit = "N.m") "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal";
  Real nonlinearSpring.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg", start = 0.0) "Relative rotation angle (= flange_b.phi - flange_a.phi)";
  Real nonlinearSpring.tau(quantity = "Torque", unit = "N.m") "Torque between flanges (= flange_b.tau)";
  Real nonlinearSpring.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real nonlinearSpring.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real nonlinearSpring.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real nonlinearSpring.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real nonlinearSpring.data.c1 = springData.c1;
  parameter Real nonlinearSpring.data.c2 = springData.c2;
  parameter Real springData.c1 = 2.0;
  parameter Real springData.c2 = 4.0;
equation
  torque.flange.phi = shaft.flange_a.phi;
  nonlinearSpring.flange_b.phi = spring.flange_b.phi;
  nonlinearSpring.flange_b.phi = load.flange_a.phi;
  fixed.flange.phi = torque.support.phi;
  fixed.flange.phi = springDamper.flange_a.phi;
  shaft.flange_b.phi = idealGear.flange_a.phi;
  nonlinearSpring.flange_a.phi = spring.flange_a.phi;
  nonlinearSpring.flange_a.phi = idealGear.flange_b.phi;
  idealGear.support.phi = housing.flange_b.phi;
  ramp.y = torque.tau;
  housing.flange_a.phi = multiSensor.flange_b.phi;
  multiSensor.flange_a.phi = springDamper.flange_b.phi;
  idealGear.flange_a.tau + shaft.flange_b.tau = 0.0;
  nonlinearSpring.flange_b.tau + spring.flange_b.tau + load.flange_a.tau = 0.0;
  load.flange_b.tau = 0.0;
  torque.support.tau + springDamper.flange_a.tau + fixed.flange.tau = 0.0;
  torque.flange.tau + shaft.flange_a.tau = 0.0;
  nonlinearSpring.flange_a.tau + idealGear.flange_b.tau + spring.flange_a.tau = 0.0;
  housing.flange_b.tau + idealGear.support.tau = 0.0;
  multiSensor.flange_b.tau + housing.flange_a.tau = 0.0;
  multiSensor.flange_a.tau + springDamper.flange_b.tau = 0.0;
  shaft.phi = shaft.flange_a.phi;
  shaft.phi = shaft.flange_b.phi;
  shaft.w = der(shaft.phi);
  shaft.a = der(shaft.w);
  shaft.J * shaft.a = shaft.flange_a.tau + shaft.flange_b.tau;
  load.phi = load.flange_a.phi;
  load.phi = load.flange_b.phi;
  load.w = der(load.phi);
  load.a = der(load.w);
  load.J * load.a = load.flange_a.tau + load.flange_b.tau;
  spring.tau = spring.c * (spring.phi_rel - spring.phi_rel0);
  spring.phi_rel = spring.flange_b.phi - spring.flange_a.phi;
  spring.flange_b.tau = spring.tau;
  spring.flange_a.tau = -spring.tau;
  fixed.flange.phi = fixed.phi0;
  springDamper.tau_c = springDamper.c * (springDamper.phi_rel - springDamper.phi_rel0);
  springDamper.tau_d = springDamper.d * springDamper.w_rel;
  springDamper.tau = springDamper.tau_c + springDamper.tau_d;
  springDamper.lossPower = springDamper.tau_d * springDamper.w_rel;
  springDamper.phi_rel = springDamper.flange_b.phi - springDamper.flange_a.phi;
  springDamper.w_rel = der(springDamper.phi_rel);
  springDamper.a_rel = der(springDamper.w_rel);
  springDamper.flange_b.tau = springDamper.tau;
  springDamper.flange_a.tau = -springDamper.tau;
  torque.flange.tau = -torque.tau;
  ramp.y = ramp.offset + (if time < ramp.startTime then 0.0 else if time < ramp.startTime + ramp.duration then (time - ramp.startTime) * ramp.height / ramp.duration else ramp.height);
  idealGear.phi_a = idealGear.flange_a.phi - idealGear.phi_support;
  idealGear.phi_b = idealGear.flange_b.phi - idealGear.phi_support;
  idealGear.phi_a = idealGear.ratio * idealGear.phi_b;
  0.0 = idealGear.ratio * idealGear.flange_a.tau + idealGear.flange_b.tau;
  housing.phi = housing.flange_a.phi;
  housing.phi = housing.flange_b.phi;
  housing.w = der(housing.phi);
  housing.a = der(housing.w);
  housing.J * housing.a = housing.flange_a.tau + housing.flange_b.tau;
  multiSensor.flange_a.phi = multiSensor.flange_b.phi;
  multiSensor.w = der(multiSensor.flange_a.phi);
  multiSensor.tau = multiSensor.flange_a.tau;
  multiSensor.power = multiSensor.tau * multiSensor.w;
  0.0 = multiSensor.flange_a.tau + multiSensor.flange_b.tau;
  nonlinearSpring.tau = BaseModelicaDemo.springCurve(nonlinearSpring.phi_rel, nonlinearSpring.data);
  nonlinearSpring.phi_rel = nonlinearSpring.flange_b.phi - nonlinearSpring.flange_a.phi;
  nonlinearSpring.flange_b.tau = nonlinearSpring.tau;
  nonlinearSpring.flange_a.tau = -nonlinearSpring.tau;
end BaseModelicaDemo.ExampleScalar;
